01/07/2020
TASK: Add support for structs.
 * ...

01/08/2020

Today, I continued working on adding support for structs. This involves
       (1) declaring the STRUCT token in the parser and adding a rule to the lexer to tokenize `struct' into STRUCT,
       (2) adding productions to the `decl_specs' non-terminal in the parser's grammar file so that it recognizes `struct' type specifiers,
       (3) implementing some kind of scoping mechanism for struct declaration,
       (4) adding type checking functions to ensure structs aren't redefined and that they are defined when used, and finally
       (5) generate code for reserving storage for structs and accessing struct members.


In the process of doing this, I started to enounter issues with 
TASK: Continue adding support for structs.

TASK: Improve handling of declaration specifiers.
C declaration specifiers come in a few different types: type specifiers (`void', `char', `int', etc.), storage class specifiers (`extern', `static', etc.), and type qualifiers (`const', `volatile', etc.). Currently, zc only supports most type specifiers but no storage class specifiers or type qualifiers.


@@@@@@@@@@@@@@@
[1 hr] Set up basic testing infrastructure.
   I copied the "runner.sh" script from Professor Linderman's midd-cool-osx GitHub repository and made a few changes to make it work better with zc's semant-main and cgen-main compiler drivers. I also created a new "tst/semant" directory and placed some simple tests in there. More complex ones are to come.

[1 hr] Wrote struct tests and fixed struct type-checking bugs.
   More bugs that I haven't fixed: structs definitions without accompanying variable declarations (e.g. `struct coords { int x; int y; };' ) never makes it past the parser. I'll fix this bug tomorrow.

01/09/2020
[1 hr] I thought about how to approach the bug mentioned in the previous entry, i.e. when the struct definition
      struct coords {
             int x;
             int y;
      };
   is made without any accompanying variable declaraiton, the parser simply drops the struct definition because there are no variables to declare. One solution that I chose not to pursue would be to
   add ``bound types'', each of which would inherit from a respective ``unbound type'' and implement a ``declarable'' interface. Then, the result of a declaration would be a list of types, some of which
   would be declarable. While this wouldn't help the above problem much, it feels like a more satisfactory approach than just checking if a type's ``sym'' field is null to determine whether it's an
   abstract or bounded type.

   Instead, I implemented more of a quick fix: if a type specifier accompanies no declarators, the declaration list simply contains one element, the type specifier. This way the parser always retains
   the struct definition.

   I also wrote some basic struct declaration tests for the semantic analyzer. It passes those.

[1 hr]
   I implemented code generation for structs and struct member access and wrote a couple tests; it appears to be working. I also fixed some semantic analysis bugs along the way.
   I expect there a few bugs related to declaration (including struct declaration) semantics currently:
     [ ] If a declaration is simply an unbound type (e.g. in the above ``struct coords'' example), the compiler currently still allocates storage for it. This is due to a quirk in how bound declarations
         and unbound types are (or, rather, aren't) distinguished. There's got to be a better way to distinguish bound and unbound types, but I can't haven't found one yet.
   And anticipated struct codegen bugs:
     [ ] compiler aborts if one struct is (validly) assigned to another of the same type. In the future, this kind of assignment should result in a call to memcpy().
   Next, I'll work on ... the sizeof operator!
   


Observations: structs can be forward-declared and defined in type casts!