/* GRAMMAR REFERENCE: http://www.cs.man.ac.uk/~pjj/bnf/c_syntax.bnf */

%{

  #include "ast.hpp"

  #define YYDEBUG 1
  #define YYLTYPE zc::SourceLoc
  #define YYLLOC_DEFAULT(Cur, Rhs, N)			\
    (Cur) = (N) ? YYRHSLOC(Rhs, 1) : YYRHSLOC(Rhs, 0);
#define yylloc g_lineno

  void yyerror(const char *);
  int yylex(void);

//  zc::SourceLoc g_lineno = 1;
  zc::TranslationUnit *g_AST_root;

  extern const char *g_filename;
  extern zc::TranslationUnit *g_translation_unit;

  int omerrs = 0; /* Number of lexing/parsing errors */

#include "util.hpp"

%}
                        
%union {
    const char *error_msg;
    int pointer;
    zc::StringExpr *string;
    zc::LiteralExpr *literal_expr;
    zc::Identifier *identifier;
    zc::TranslationUnit *translation_unit;
    zc::ExternalDecls *external_decls;
    zc::FunctionDef *function_def;
    zc::Decls *decls;
    zc::Decl *decl;
    zc::TypeSpec type_spec;
    zc::DeclSpecs *decl_specs;
    zc::ASTDeclarators *declarators;
    zc::ASTDeclarator *declarator;
    zc::Decls *param_types;
    zc::Decl *param_type;
    zc::Decl *param_decl;
    zc::Decls *param_decls;
    zc::ASTStat *stat;
    zc::ASTStats *stats;
    zc::CompoundStat *compound_stat;
    zc::ExprStat *expr_stat;
    zc::ASTExpr *expr;
    zc::AssignmentExpr *assignment_expr;
    zc::BinaryExpr::Kind binary_operator;
    zc::UnaryExpr::Kind unary_operator;
}

%initial-action {
    @$ = 1;
}                   

/* terminals */
%token ERROR

                         /* -- BINARY OPERATORS */
%token EQ       /* '==' */
%token NEQ      /* '!=' */
%token LEQ      /* '<=' */
%token GEQ      /* '>=' */
%token OR   /* '||' */
%token AND  /* '&&' */

 /* TYPES */
%token VOID
%token CHAR
%token SHORT            
%token INT
%token LONG
%token <string> STRING  
%token <expr> INT_CONST
%token <expr> CHAR_CONST
%token <identifier> ID

 /* CONTROL */
%token RETURN

                         /* IDENTIFIERS */
%type  <translation_unit> translation_unit
%type  <external_decls> external_decl
%type  <function_def>  function_definition
%type  <decls>         optional_decl_list decl_list decl
%type  <decl_specs>    decl_specs
%type  <declarators>   init_declarator_list optional_init_declarator_list
%type  <declarator>    init_declarator declarator direct_declarator
%type  <pointer>       pointer
%type  <param_decl>    param_decl
%type  <param_decls>   param_type_list param_list
%type  <stat>          stat jump_stat
%type  <stats>         optional_stat_list stat_list
%type  <compound_stat> compound_stat
%type  <expr_stat>     exp_stat
%type  <expr>          optional_exp exp
%type  <assignment_expr> assignment_exp
%type  <expr>          postfix_exp primary_exp unary_exp conditional_exp logical_or_exp logical_and_exp inclusive_or_exp exclusive_or_exp and_exp equality_exp relational_exp shift_expression additive_exp mult_exp cast_exp constant_exp
%type  <binary_operator> relational_operator additive_operator mult_operator equality_operator
%type  <unary_operator> unary_operator
%type   <type_spec>     type_spec
                                             
%%

translation_unit:
                external_decl {
                    g_AST_root = $$ = zc::TranslationUnit::Create(zc::ExternalDecls::Create(@1), @1);
                    $$->decls()->vec().insert($$->decls()->vec().end(),
                                              $1->vec().begin(),
                                              $1->vec().end());
                }
        |       translation_unit external_decl {
                  $$ = $1;
                  $$->decls()->vec().insert($$->decls()->vec().end(),
                                           $2->vec().begin(),
                                           $2->vec().end());
                }
        ;
external_decl:  function_definition { $$ = zc::ExternalDecls::Create((zc::ExternalDecl *) $1, @1); }
        |       decl { $$ = zc::ExternalDecls::Create
                        ((zc::ASTNodeVec<zc::Decl> *) $1,
                         [&](zc::Decl *decl) -> zc::ExternalDecl * {
                            return zc::ExternalDecl::Create(decl, @1);
                        }, @1); }
        ;
function_definition:
                decl_specs declarator compound_stat {
                    $$ = zc::FunctionDef::Create
                        ($3,
                         zc::Decl::Create($1, $2, @1),                         
                         @1);
                }
        ; /* incomplete */
optional_decl_list:
                /* empty */ { $$ = zc::Decls::Create(@$); }
        |       decl_list { $$ = $1; }
        ;
decl_list:      decl
        |       decl_list decl { $1->vec().insert($1->vec().end(), $2->vec().begin(), $2->vec().end()); }
        ;
decl:           decl_specs optional_init_declarator_list ';' {
                    $$ = zc::Decls::Create(@1);
                    for (auto decl : $2->vec()) {
                        $$->vec().push_back(zc::Decl::Create($1, decl, @1));
                    }
                }
        ;
decl_specs:     type_spec { $$ = zc::DeclSpecs::Create(@1); $$->type_specs()->insert($1); }
        |       decl_specs type_spec { $$ = $1; $$->type_specs()->insert($2); }
        ; /* incomplete */
type_spec:      VOID { $$ = zc::TypeSpec::TYPE_VOID; }
        |       CHAR { $$ = zc::TypeSpec::TYPE_CHAR; }
        |       SHORT { $$ = zc::TypeSpec::TYPE_SHORT; }
        |       INT { $$ = zc::TypeSpec::TYPE_INT; }
        |       LONG { $$ = zc::TypeSpec::TYPE_LONG; }
        ;
optional_init_declarator_list:
                /* empty */ { $$ = zc::ASTDeclarators::Create(@$); @$ = 0; }
        |       init_declarator_list
        ;
init_declarator_list:
                        init_declarator { $$ = zc::ASTDeclarators::Create(@1); $$->vec().push_back($1); }
                |       init_declarator_list ',' init_declarator { $$ = $1; $$->vec().push_back($3); }
        ; /* incomplete */
init_declarator:
                declarator
        ; /* incomplete */
declarator:     direct_declarator { $$ = $1; }
        |       pointer direct_declarator { $$ = zc::PointerDeclarator::Create($1, $2, @1); }
        ;
direct_declarator:
                ID { $$ = zc::BasicDeclarator::Create($1, @1); }
        |       '(' declarator ')' { $$ = $2; }
        |       direct_declarator '(' param_type_list ')' { $$ = zc::FunctionDeclarator::Create($1, $3, @1); }
        ; /* incomplete */
pointer:        '*' { $$ = 1; }
        |       '*' pointer { $$ = $2 + 1; }
        ;
param_type_list:
                param_list
        ; /* incomplete */
param_list:     param_decl { $$ = zc::Decls::Create(@1); $$->vec().push_back($1); }
        |       param_list ',' param_decl { $$ = $1; $$->vec().push_back($3); }
        ;
param_decl:     decl_specs declarator { $$ = zc::Decl::Create($1, $2, @1); }
        ; /* incomplete */
stat:           exp_stat { $$ = $1; }
        |       compound_stat { $$ = $1; }
        |       jump_stat { $$ = $1; }                
        ; /* incomplete */
optional_stat_list:
                /* empty */ { $$ = zc::ASTStats::Create(@$); @$ = 0; }
        |       stat_list { $$ = $1; }
        ;
stat_list:      stat { $$ = zc::ASTStats::Create(@1); $$->vec().push_back($1); }
        |       stat_list stat { $$->vec().push_back($2); }
        ;
compound_stat:  '{' optional_decl_list optional_stat_list '}' {
                    $$ = zc::CompoundStat::Create($2, $3, @1);
                }
        ;
jump_stat:      RETURN optional_exp ';' { $$ = zc::ReturnStat::Create($2, @1); }
        ;
exp_stat:       optional_exp ';' { $$ = zc::ExprStat::Create($1, @1); }
        ;
optional_exp:   /* empty */ { $$ = zc::NoExpr::Create(@$); @$ = 0; }
        |       exp         { $$ = $1; }
        ;
exp:            assignment_exp { $$ = $1; }
        ; /* incomplete */
assignment_exp: unary_exp '=' conditional_exp { $$ = zc::AssignmentExpr::Create($1, $3, @1); }
        ; /* incomplete */
conditional_exp:
                logical_or_exp
        ; /* incomplete */
unary_exp:      postfix_exp
        |       unary_operator unary_exp { $$ = zc::UnaryExpr::Create($1, $2, @1); }
        ; /* incomplete */
logical_or_exp: logical_and_exp
        |       logical_or_exp OR logical_and_exp {
                    $$ = zc::BinaryExpr::Create(zc::BinaryExpr::Kind::BOP_LOGICAL_OR, $1, $3, @1);
                }
        ;
logical_and_exp:
                inclusive_or_exp
        |       logical_and_exp AND inclusive_or_exp {
                    $$ = zc::BinaryExpr::Create(zc::BinaryExpr::Kind::BOP_LOGICAL_AND, $1, $3, @1);
                }
        ;
inclusive_or_exp:
                exclusive_or_exp
        |       inclusive_or_exp '|' exclusive_or_exp {
                    $$ = zc::BinaryExpr::Create(zc::BinaryExpr::Kind::BOP_BITWISE_OR, $1, $3, @1);
                }
        ;
exclusive_or_exp:
                and_exp
        |       exclusive_or_exp '^' and_exp {
                    $$ = zc::BinaryExpr::Create(zc::BinaryExpr::Kind::BOP_BITWISE_XOR, $1, $3, @1);
                }
        ;
and_exp:        equality_exp
        |       and_exp '&' equality_exp {
                    $$ = zc::BinaryExpr::Create(zc::BinaryExpr::Kind::BOP_BITWISE_AND, $1, $3, @1);
                }           
        ;
equality_exp:   relational_exp
        |       equality_exp equality_operator relational_exp {
                    $$ = zc::BinaryExpr::Create($2, $1, $3, @1);
                }
        ;
relational_exp: shift_expression
        |       relational_exp relational_operator shift_expression {
                    $$ = zc::BinaryExpr::Create($2, $1, $3, @1);
                }
        ;
shift_expression:
                additive_exp
        ; /* incomplete */
additive_exp:   mult_exp
        |       additive_exp additive_operator mult_exp {
                    $$ = zc::BinaryExpr::Create($2, $1, $3, @1);
                }
        ;
mult_exp:       cast_exp
        |       mult_exp mult_operator cast_exp {
                    $$ = zc::BinaryExpr::Create($2, $1, $3, @1);
                }
        ;
cast_exp:       unary_exp
        ; /* incomplete */

postfix_exp:    primary_exp
        ; /* incomplete */

primary_exp:    ID { $$ = zc::IdentifierExpr::Create($1, @1); }
        |       constant_exp
        |       '(' exp ')' { $$ = $2; }
        ; /* incomplete */
constant_exp:   INT_CONST
        |       CHAR_CONST
        ; /* incomplete */

equality_operator:
                EQ { $$ = zc::BinaryExpr::Kind::BOP_EQ; }
        |       NEQ { $$ = zc::BinaryExpr::Kind::BOP_NEQ; }
        ;
relational_operator:
                '<' { $$ = zc::BinaryExpr::Kind::BOP_LT; }
        |       LEQ { $$ = zc::BinaryExpr::Kind::BOP_LEQ; }
        ; /* incomplete */
additive_operator:
                '+' { $$ = zc::BinaryExpr::Kind::BOP_PLUS; }
        |       '-' { $$ = zc::BinaryExpr::Kind::BOP_MINUS; }
        ;
mult_operator:  '*' { $$ = zc::BinaryExpr::Kind::BOP_TIMES; }
        |       '/' { $$ = zc::BinaryExpr::Kind::BOP_DIVIDE; }
        |       '%' { $$ = zc::BinaryExpr::Kind::BOP_MOD; }
        ;
unary_operator: '&' { $$ = zc::UnaryExpr::Kind::UOP_ADDR; }
        |       '*' { $$ = zc::UnaryExpr::Kind::UOP_DEREFERENCE; }
        |       '+' { $$ = zc::UnaryExpr::Kind::UOP_POSITIVE; }
        |       '-' { $$ = zc::UnaryExpr::Kind::UOP_NEGATIVE; }
        |       '~' { $$ = zc::UnaryExpr::Kind::UOP_BITWISE_NOT; }
        |       '!' { $$ = zc::UnaryExpr::Kind::UOP_LOGICAL_NOT; }
        ;

%%

void yyerror(const char *s) {
    extern zc::SourceLoc g_lineno;

    std::cerr << "\"" << g_filename << "\", " << "line " << g_lineno << ": " << s << " at or near ";
    zc::print_token(std::cerr, yychar, yylval);
    std::cerr << std::endl;

    ++omerrs;

    if (omerrs > 50) {
        std::cerr << "More than 50 errors" << std::endl;
        exit(1);
    }
}
